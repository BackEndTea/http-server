<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>Aerys and Dynamic Applications</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="Daniel Lowrey">

    <link href="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/css/bootstrap-combined.min.css" rel="stylesheet">
    <link href="/favicon.ico" rel="icon" type="image/x-icon" />
    <link href="/css/additional.css" rel="stylesheet" type="text/css">
      
    <!-- HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="../assets/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body>

    <div class="container">

      <div class="masthead">
        <div class="navbar">
          <div class="navbar-inner">
            <div class="container">
              <ul class="nav">
                <li><a href="/">Home</a></li>
                <li class="active"><a href="/apps.html">Applications</a></li>
                <li><a href="/static/">Static Files</a></li>
                <li><a href="/websockets/">Websockets</a></li>
                <li><a href="/mods/">Mods</a></li>
                <li><a href="/asgi.html">ASGI</a></li>
              </ul>
            </div>
          </div>
        </div><!-- /.navbar -->
      </div>
      
      <h1>Dynamic Web Applications</h1>
      <p class="lead">Aerys brings dynamic PHP web apps and websockets together in a single package.</p>
      <hr />
      
      <h3>Built-in Application Handlers</h3>
      
      <table class="table table-striped">
        <thead>
          <tr>
            <th>Handler</th><th>Description</th>
          </tr>
        </thead>
        <tbody>
          
          <tr>
            <td>DocRoot</td>
            <td>
              Static filesystem resources are an important part of any modern web application.
              Aerys fills this need with its HTTP/1.1-compliant static file handler. Prime your app
              for scalability by hosting static files from a named subdomain such as
              <i>http://static.mysite.com</i> to allow a seamless transition down the road to a CDN
              or server optimized for file serving as your needs change.<br />
              
              <a href="/static/">Read more about the static file handler ...</a>
            </td>
          </tr>
          
          <tr>
            <td>ReverseProxy</td>
            <td>
              Proxy requests for named hosts to any one of several backend servers identified by
              IP and port. This handler makes it possible to easily layer websocket endpoints on top
              of an existing web application.
            </td>
          </tr>
          
          <tr>
            <td>Websockets</td>
            <td>
              OMG can PHP really solve the <a href="http://www.kegel.com/c10k.html">C10K Problem</a>
              and do <i>webscale</i>? Yes. Aerys makes websockets as outlined in
              <a href="http://tools.ietf.org/html/rfc6455" title="RFC 6455"> RFC 6455</a> a first
              class citizen. Traditional PHP websocket solutions require a proxy server because the
              real front-facing server -- be it Lighttpd, Apache, Nginx, etc -- is already taking up
              the ports (80/443) on which the websocket protocol listens. Because Aerys is its own
              event-driven server it can delegate control of the appropriate client sockets as needed
              to its own websocket handling mechanism.
              
              <a href="/websockets.html">Read more about the websocket handler ...</a>
            </td>
          </tr>
          
        </tbody>
      </table>
      
      <hr />
      
      <h3>Why? For the Love of Lerdorf, Why?</h3>
      <p>
        PHP trivializes the creation of dynamic web applications by abstracting the underyling HTTP
        protocol. This establishment of HTTP as a first-class language citizen makes PHP a formidable
        development platform; anyone -- regardless of how little that person knows about HTTP -- can
        use it to crank out dynamic web apps. Meanwhile, a funny thing happened as PHP's
        popularity grew: it evolved into a language with a full suite of enterprise-grade features.
        A robust object model, lambda functions, generators and more are all at the fingertips of the PHP
        programmer. But as PHP has evolved into a full-fledged programming language, it has unfortunately
        also clung tightly to its an unwavering dependence on third-party webservers.
      </p>
      
      <p>
        Want to write a PHP web application? Well you had better snag a copy of Apache/Nginx/Lighttpd/etc.
        This circa-1996 paradigm has historically served the language well, but the cracks are starting
        to show. The repetitive request-response action on which standard PHP SAPIs rely is under fire;
        cutting edge applications are moving to the newly standardized Websocket protocol to create
        desktop-style applications in the browser. Buzzwords like <em>webscale</em> have driven
        developers en masse to servers capable of long-lived concurrent connections numbering in the
        thousands. And despite the winks and nudges we associate with words like <em>webscale</em>, 
        they still carry some meaning (beyond pointless marketing-speak). The simple fact is that this
        kind of development exceeds the reach of PHP running behind a third-party web server.
      </p>
      
      <blockquote>
        <p class="lead">PHP behind a web SAPI is simply not "webscale."</p>
      </blockquote>
      
      <p>
        In addition to this problem the language carries some real warts. The first thing every programmer
        learns (after "Hello, World," of course) is that <em>global state is evil</em>. But PHP 
        blows right through that stop sign and gives us ... wait for it ... <em>SUPERGLOBALS!</em> Further, in an
        effort to dumb down the HTTP protocol for the masses the language has created a whole horde
        of disparate functions to send headers, set cookies, etc. Though well-meaning, these abstractions
        make a real mess of the protocol. PHP is largely responsible for a generation of web developers
        who don't know the first thing about how the actual web works.
      </p>
      
      <p>
        One would also expect a language in which HTTP is considered a first-class citizen to provide
        full access to the protocol. Have you tried responding to an <code>Expect: 100-continue</code>
        request header before the entity body arrives in a PHP app? <em>Hint: you can't</em>. Even worse,
        names like <code>$_GET</code> and <code>$_POST</code> are outright misleading and don't actually
        map to the GET/POST methods. Need to access the entity body of a PUT request in your RESTful
        PHP app? It's in the <code>$_PUT</code> superglobal right? No? You mean it's in <code>php://input</code>?
        Man, this abstraction got leaky fast...
      </p>
      
      <h3>But This Is Not A Rant</h3>
      
      <p>
        In spite of everything, PHP is still that furry purple elephant we all love. It's great. We can do
        so many really cool things with it. And to that end the main goal of the Aerys project is to
        help PHP move into the 21st century of web development. In service of that goal an Aerys
        server exposes solid HTTP abstractions while still being easy to use if you don't
        know anything about the actual HTTP protocol. Additionally, Aerys makes it trivial to serve
        websocket applications alongside PHP web apps without the need for a proxy server. Oh, and
        it's fast.
      </p>
      
      <hr />
      
      <div class="footer">
        <p>&copy; <a href="http://chat.stackoverflow.com/transcript/message/7857491#7857491">Lusitanian's Mom</a> 2013</p>
      </div>

    </div> <!-- /container -->

    <!-- Le javascript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script src="//netdna.bootstrapcdn.com/twitter-bootstrap/2.3.1/js/bootstrap.min.js"></script>

  </body>
</html>

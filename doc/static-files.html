<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Aerys: Static Files</title>
<link rel="stylesheet" href="https://stackedit.io/res-min/themes/base.css" />
<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body><div class="container"><h1 id="aerys-static-files">Aerys: Static Files</h1>

<blockquote>
  <p><strong><a href="#table-of-contents">Table of Contents</a></strong></p>
</blockquote>



<h2 id="serving-static-files">Serving Static Files</h2>

<p>Aerys exposes fully HTTP/1.1-compliant static file serving capabilities. Highlights include:</p>

<ul>
<li>Stream media with  partial and multipart <code>byte-range</code> responses</li>
<li>Minimize bandwidth usage and response time via caching/precondition headers </li>
<li>Customize document root settings for each individual host in your server</li>
<li>Streamline file serving behind dynamic application logic via <code>Sendfile:</code> headers</li>
<li>Expose turnkey websocket applications; serve websocket HTML and Javascript files with no need for proxies or additional servers</li>
</ul>

<blockquote>
  <p><strong>NOTE</strong></p>
  
  <p>Though no extension is <em>required</em> to use Aerys’s static serving capabilities, production environments <em>SHOULD</em> deploy the <code>php-uv</code> extension. Native PHP cannot serve static files in a non-blocking way on its own. Aerys uses <code>php-uv</code> to service static file requests without blocking the server’s event loop when available.</p>
</blockquote>



<h2 id="configuring-the-document-root">Configuring the Document Root</h2>

<p>Static document root settings are defined on a per-host basis using  <code>Aerys\Host</code> instances in the server configuration file. Hosts expose the following method to add static file serving on a domain:</p>



<pre class="prettyprint"><code class=" hljs lasso">Host<span class="hljs-tag">::setRoot</span>(<span class="hljs-built_in">string</span> <span class="hljs-variable">$pathToMyFiles</span>, <span class="hljs-built_in">array</span> <span class="hljs-variable">$options</span> <span class="hljs-subst">=</span> <span class="hljs-preprocessor">[</span><span class="hljs-preprocessor">]</span><span class="hljs-markup">);</span></code></pre>

<p>The following simple aerys configuration serves static files from the <code>/path/to/my/documents</code> directory for the <em>mysite.com</em> host:</p>



<pre class="prettyprint"><code class="language-php hljs "><span class="hljs-preprocessor">&lt;?php</span> <span class="hljs-comment">// Serve static files on mysite.com port 80</span>
<span class="hljs-keyword">use</span> <span class="hljs-title">Aerys</span>\<span class="hljs-title">Host</span>;

<span class="hljs-variable">$mySite</span> = <span class="hljs-keyword">new</span> Host;
<span class="hljs-variable">$mySite</span>-&gt;setName(<span class="hljs-string">'mysite.com'</span>);
<span class="hljs-variable">$mySite</span>-&gt;setRoot(<span class="hljs-string">'/path/to/my/documents'</span>);</code></pre>

<p>That’s it! We now have a fully-functioning static file server listening on port 80 for requests to <em>mysite.com</em>. Any requests will be served from the path specified in our <code>Host::setRoot()</code> call. Of course, we’ll generally want to serve some dynamic HTTP resource endpoints in addition to our static files. Lets look at a simple example of how static file serving interacts with routed HTTP application endpoints:</p>



<pre class="prettyprint"><code class="language-php hljs "><span class="hljs-preprocessor">&lt;?php</span> <span class="hljs-comment">// Serve dynamic, websocket and static endpoints</span>
<span class="hljs-keyword">use</span> <span class="hljs-title">Aerys</span>\<span class="hljs-title">Host</span>;

<span class="hljs-variable">$mySite</span> = <span class="hljs-keyword">new</span> Host;
<span class="hljs-variable">$mySite</span>-&gt;setName(<span class="hljs-string">'mysite.com'</span>);
<span class="hljs-variable">$mySite</span>-&gt;setRoot(<span class="hljs-string">'/path/to/my/documents'</span>);
<span class="hljs-variable">$mySite</span>-&gt;addRoute(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'/dynamic'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> <span class="hljs-keyword">return</span> <span class="hljs-string">'hello world'</span>; });
<span class="hljs-variable">$mySite</span>-&gt;addWebsocket(<span class="hljs-string">'/mywebsocket'</span>, <span class="hljs-string">'MyWebsocketClass'</span>);</code></pre>

<p>The above configuration aerys routes requests to <code>/mywebsocket</code> to our specified websocket handler. <code>GET</code> requests to <code>http://mysite.com/dynamic</code> are routed to the “hello world” handler. All other requests are served from our static document root  at <code>/path/to/my/documents</code>.</p>

<blockquote>
  <p><strong>NOTE</strong></p>
  
  <p>The order in which routes/websockets/static files are specified in the configuration file has no effect on routing order. Dynamic routes <em>always</em> take precedence over static files in the event of a routing conflict. This means your static document root will <em>only</em> be used if a dynamic endpoint for the requested path does not exist.</p>
</blockquote>



<h3 id="assigning-options">Assigning Options</h3>

<p>The <code>$options</code> parameter allows users to fine-tune the behavior of their static file resources as shown here:</p>



<pre class="prettyprint"><code class="language-php hljs "><span class="hljs-preprocessor">&lt;?php</span> <span class="hljs-comment">// Server config customizing static serving options</span>
<span class="hljs-keyword">use</span> <span class="hljs-title">Aerys</span>\<span class="hljs-title">Host</span>;

<span class="hljs-variable">$mySite</span> = <span class="hljs-keyword">new</span> Host;
<span class="hljs-variable">$mySite</span>-&gt;setName(<span class="hljs-string">'mysite.com'</span>);
<span class="hljs-variable">$mySite</span>-&gt;setRoot(<span class="hljs-string">'/path/to/files'</span>, <span class="hljs-variable">$options</span> = [
    <span class="hljs-string">'indexes'</span>       =&gt; [<span class="hljs-string">'index.html'</span>, <span class="hljs-string">'index.htm'</span>],
    <span class="hljs-string">'expiresPeriod'</span> =&gt; <span class="hljs-number">3600</span>,
]);</code></pre>



<h3 id="option-reference">Option Reference</h3>

<p>The following document root option keys (case-insensitive) are available in the <code>Host::setRoot()</code> options array.</p>

<table>
<thead>
<tr>
  <th>Option Key</th>
  <th>Description</th>
  <th>Default</th>
</tr>
</thead>
<tbody><tr>
  <td>cacheTtl</td>
  <td>The number of seconds to cache filesystem stat results, open file descriptors and buffered file contents</td>
  <td>10</td>
</tr>
<tr>
  <td>cacheMaxBuffers<sup>†</sup></td>
  <td>The maximum number of files that will be buffered in memory at any given time.</td>
  <td>50</td>
</tr>
<tr>
  <td>cacheMaxBufferSize<sup>†</sup></td>
  <td>The maximum file size above which request file contents will no longer be buffered in-memory</td>
  <td>524288</td>
</tr>
<tr>
  <td>defaultCharset</td>
  <td>The default character set for text mime types</td>
  <td>utf-8</td>
</tr>
<tr>
  <td>defaultMimeType</td>
  <td>The default mime type to send if no matching extension found in the <code>mimeTypes</code> or <code>mimeFile</code> setting</td>
  <td>text/plain</td>
</tr>
<tr>
  <td>expiresPeriod</td>
  <td>The number of seconds until HTTP caches should consider their resource representations stale</td>
  <td>3600</td>
</tr>
<tr>
  <td>indexes</td>
  <td>An optional list of directory index filenames to display on requests for a directory path</td>
  <td>index.html</td>
</tr>
<tr>
  <td>mimeFile</td>
  <td>An optional file specifying extension to mime type mappings</td>
  <td>etc/mime</td>
</tr>
<tr>
  <td>mimeTypes</td>
  <td>An key-value array mapping file extensions to mime types</td>
  <td>n/a</td>
</tr>
<tr>
  <td>private</td>
  <td>If this boolean option is enabled files in the document root can only be served when application endpoints specify a <code>Sendfile:</code> response header</td>
  <td>false</td>
</tr>
<tr>
  <td>useEtagInode</td>
  <td>Should file inodes be used when generating <code>Etag:</code> headers</td>
  <td>true</td>
</tr>
</tbody></table>


<blockquote>
  <p><strong><sup>†</sup></strong> cached file content buffers are NOT shared across server process instances. The maximum memory exposure from cached file buffers at any one time grows linearly with the number of concurrent server processes. The use of cached content buffers may be disabled by setting <code>"cacheMaxBuffers" =&gt; 0</code>.</p>
</blockquote>



<h2 id="features-and-considerations">Features and Considerations</h2>



<h3 id="sendfile">Sendfile</h3>

<p>Applications often need to serve static file system resources with some additional logic or processing. Or perhaps only authenticated users should have access to static files. For such use-cases Aerys provides the <code>Sendfile:</code> header.</p>

<p>Any host that specifies a document root can use the <code>Sendfile</code> header to directly relay a files contents. For example:</p>



<pre class="prettyprint"><code class="language-php hljs "><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-keyword">use</span> <span class="hljs-title">Aerys</span>\<span class="hljs-title">Host</span>;

<span class="hljs-variable">$host</span> = <span class="hljs-keyword">new</span> Host(<span class="hljs-string">'mysite.com'</span>);
<span class="hljs-variable">$host</span>-&gt;setRoot(<span class="hljs-string">'/path/to/files'</span>);

<span class="hljs-comment">// GET /myfunction -&gt; /path/to/files/file1.html</span>
<span class="hljs-variable">$host</span>-&gt;addRoute(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'/myfunction'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-variable">$request</span>)</span> {</span>
    <span class="hljs-comment">// some application logic here</span>
    <span class="hljs-keyword">return</span> [<span class="hljs-string">'header'</span> =&gt; <span class="hljs-string">'Sendfile: file1.html'</span>];
});

<span class="hljs-comment">// GET /mygenerator -&gt; /path/to/files/file2.html</span>
<span class="hljs-variable">$host</span>-&gt;addRoute(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'/mygenerator'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-variable">$request</span>)</span> {</span>
    <span class="hljs-keyword">yield</span> <span class="hljs-string">'header'</span> =&gt; <span class="hljs-string">'Sendfile: /file2.html'</span>;
});</code></pre>



<h3 id="designing-for-scalability">Designing for Scalability</h3>

<p>When planning a naming scheme applications should generally expose static files under a separate subdomain from dynamic resources. Why? There are a couple of reasons …</p>

<ol>
<li>Browsers will only open a limited number of TCP connections on a per host-name basis when utilizing the HTTP/1.1 protocol<sup>†</sup>. By serving static files from a separate subdomain browsers will retrieve static resources at the same time as dynamic resources resulting in faster page loads.</li>
<li>Decoupling static resources from an application’s primary domain name makes it much easier to move to a CDN or technology optimized for static file serving in the future. If, for example, all static files are served from <code>static.mysite.com</code> an application can simply modify a DNS entry to point this subdomain to a new IP when migrating file serving to new locations.</li>
</ol>

<p>Aerys makes adding multiple host names trivial. Here’s an example demonstrating how to serve dynamic resources from one domain while serving static resources from another in the same server instance:</p>



<pre class="prettyprint"><code class=" hljs xml"><span class="php"><span class="hljs-preprocessor">&lt;?php</span> <span class="hljs-comment">// Multi-domain static file server</span>
<span class="hljs-keyword">use</span> <span class="hljs-title">Aerys</span>\<span class="hljs-title">Host</span>;

<span class="hljs-comment">// Main domain</span>
<span class="hljs-variable">$mySite</span> = <span class="hljs-keyword">new</span> Host;
<span class="hljs-variable">$mySite</span>-&gt;setName(<span class="hljs-string">'mysite.com'</span>);
<span class="hljs-variable">$mySite</span>-&gt;addRoute(<span class="hljs-string">'GET'</span>, <span class="hljs-string">'/'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(<span class="hljs-variable">$request</span>)</span> {</span>
    <span class="hljs-variable">$img</span> = <span class="hljs-string">'http://static.mysite.com/my-image.jpg'</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-string">"&lt;html&gt;&lt;body&gt;&lt;img src="</span>{<span class="hljs-variable">$img</span>}<span class="hljs-string">"/&gt;&lt;/body&gt;&lt;/html&gt;"</span>;
});

<span class="hljs-comment">// Define a subdomain to host static files</span>
<span class="hljs-variable">$subdomain</span> = <span class="hljs-keyword">new</span> Host;
<span class="hljs-variable">$subdomain</span>-&gt;setName(<span class="hljs-string">'static.mysite.com'</span>);
<span class="hljs-variable">$subdomain</span>-&gt;setRoot(<span class="hljs-string">'/path/to/my/files'</span>);</span></code></pre>

<blockquote>
  <p><strong><sup>†</sup></strong> Though drafts for the future HTTP/2.0 (h2) protocol help mitigate this situation by multiplexing requests over a single TCP connection, HTTP/1.1 will be around for decades to come.</p>
</blockquote>



<h3 id="stat-caching">Stat Caching</h3>

<p>Compared to most CPU-bound operations, IO-bound operations like filesystem accesses are <em>slow</em>. Moreover, static file attributes are unlikely to change over short time frames. To improve static file serving performance Aerys caches the results of file <code>stat()</code> operations for a limited amount of time. The time-to-live (TTL) for these cache entries is subject to the <code>cacheTtl</code> option setting when invoking <code>Host::setRoot()</code>. By default, cached file stats persist for ten seconds.</p>

<blockquote>
  <p><strong>NOTE</strong></p>
  
  <p>When running a server in debug mode a force-refresh in your browser will refresh any cached <code>stat()</code> results for the resources to shorten the development feedback loop.</p>
</blockquote>



<h3 id="buffer-caching">Buffer Caching</h3>

<p>To improve performance Aerys temporarily buffers the contents of small files in-memory to avoid hitting the filesystem on subsequent requests for the same resource. Buffer caching functionality is governed by three options:</p>

<ol>
<li><code>cacheTtl</code></li>
<li><code>cacheMaxBuffers</code></li>
<li><code>cacheMaxBufferSize</code></li>
</ol>

<p>When a file is requested whose size (in bytes) is less than the <code>cacheMaxBufferSize</code> setting the server will buffer it in memory for <code>cacheTtl</code> seconds. If the number of cached buffers reaches <code>cacheMaxBuffers</code> no new files will be buffered until TTL timeouts result in the removal of previously buffered entries from the cache.</p>

<p>An example configuration modifying these settings is shown here for reference:</p>



<pre class="prettyprint"><code class=" hljs xml"><span class="php"><span class="hljs-preprocessor">&lt;?php</span>
<span class="hljs-keyword">use</span> <span class="hljs-title">Aerys</span>\<span class="hljs-title">Host</span>;

<span class="hljs-variable">$host</span> = <span class="hljs-keyword">new</span> Host(<span class="hljs-string">'mysite.com'</span>);
<span class="hljs-variable">$host</span>-&gt;setRoot(<span class="hljs-string">'/path/to/my/files'</span>, <span class="hljs-variable">$options</span> = [
    <span class="hljs-string">'cacheTtl'</span>           =&gt; <span class="hljs-number">5</span>,     <span class="hljs-comment">// seconds until cache entry is stale</span>
    <span class="hljs-string">'cacheMaxBuffers'</span>    =&gt; <span class="hljs-number">25</span>,    <span class="hljs-comment">// don't cache more than 25 files at once</span>
    <span class="hljs-string">'cacheMaxBufferSize'</span> =&gt; <span class="hljs-number">32768</span>, <span class="hljs-comment">// only buffer a file if smaller than 32kb</span>
]);</span></code></pre>

<hr>



<h2 id="table-of-contents">Table of Contents</h2>

<p><div class="toc">
<ul>
<li><a href="#aerys-static-files">Aerys: Static Files</a><ul>
<li><a href="#serving-static-files">Serving Static Files</a></li>
<li><a href="#configuring-the-document-root">Configuring the Document Root</a><ul>
<li><a href="#assigning-options">Assigning Options</a></li>
<li><a href="#option-reference">Option Reference</a></li>
</ul>
</li>
<li><a href="#features-and-considerations">Features and Considerations</a><ul>
<li><a href="#sendfile">Sendfile</a></li>
<li><a href="#designing-for-scalability">Designing for Scalability</a></li>
<li><a href="#stat-caching">Stat Caching</a></li>
<li><a href="#buffer-caching">Buffer Caching</a></li>
</ul>
</li>
<li><a href="#table-of-contents">Table of Contents</a></li>
</ul>
</li>
</ul>
</div>
</p></div></body>
</html>